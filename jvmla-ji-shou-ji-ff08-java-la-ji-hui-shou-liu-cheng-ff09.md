## GC流程

所有的数据都会保存在JVM的堆内存中，但是在实际的开发之中，我们经常会创建许多的临时对象，也会有很多常驻对象存在，所以为了保证GC的性能问题，对于GC的处理流程如下图所示：

![](/assets/3071517030847_.pic_hd.jpg)

对于整个的GC流程里面，最需要处理的就是年轻带和老年代的内存的清理操作，而元空间（永久带）都不在GC范围内。

1. 当现在有一个新的对象产生，那么我们对象一定需要内存空间（平均每一个栈内存存4K，每一个堆内存存8K），于是现在就需要为该对象进行内存空间的申请。

2. 首先会判断伊甸园区是否有你内存空间，如果此时有内存空间，则直接将对象保存在伊甸园区。

3. 但是如果此时伊甸园区的内存空间不足，那么会自动执行一个Minor GC操作，将伊甸园区的无用的内存空间进行清理。，当清理之后会继续判断伊甸园区的内存空间是否充足？充足的话则将新的对象直接在伊甸园区进行空间分配

4. 如果执行了Minor GC之后伊甸园区的内存依然不足，那么这个时候会进行存活区的判断，如果这个时候存活区有剩余空间，则将伊甸园区的部分活跃对象保存在存活区，那么随后继续判断伊甸园区的内存是否充足，如果充足则在伊甸园区进行新对象的分配。

5. 如果存活区也已经没有内存空间了，则继续判断老年区。如果此时老年区空间充足，则将存活区中的活跃对象保存到老年代。而后存活区就会出现有空余空间，随后伊甸园区将活跃对象保存在存活区中，而后在伊甸园区里面创立新对象且开辟内存空间。

6. 如果这个时候老年代也满了，那么这个时候讲产生Major GC 进行老年代的内存清理。

7. 如果老年代执行了Full GC之后发现依然无法进行对象的保存，这个时候就会出现OOM异常。